import{_ as a,a as e,o as t,aR as o}from"./chunks/framework.Dl98zJwX.js";const P=JSON.parse('{"title":"12.TCP 滑动窗口、重试机制","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/http/12.TCP 滑动窗口、重试机制.md","filePath":"前端/面试题/http/12.TCP 滑动窗口、重试机制.md","lastUpdated":1720603948000}'),r={name:"前端/面试题/http/12.TCP 滑动窗口、重试机制.md"},i=o('<h1 id="_12-tcp-滑动窗口、重试机制" tabindex="-1">12.TCP 滑动窗口、重试机制 <a class="header-anchor" href="#_12-tcp-滑动窗口、重试机制" aria-label="Permalink to &quot;12.TCP 滑动窗口、重试机制&quot;">​</a></h1><h2 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to &quot;滑动窗口&quot;">​</a></h2><p>我能接受多少数据，</p><blockquote><p>为 TCP 是顺序发送的，操作系统将这些数据包一批一批的发送给对方，就像一个窗口，不停地往后移动，所以，我们称之为 TCP 滑动窗口协议 滑动窗口能够提高 TCP 数据的传输性能。因为 TCP 无须对　　每一数据段进行确认, 只需要对发送一个窗口宽度的段确认一次。</p></blockquote><p>滑动窗口的大小对网络性能有很大的影响。如果滑动窗口过小, 则需要在网络上频繁的传输确认信息, 占用了大量的网络带宽; 如果滑动窗口过大, 对于利用率较高、容易产生丢包现象的网络, 则需要多次发送重复的数据, 这同样耗费了网络带宽。 　　决定滑动窗口大小的因素, 包括网络的带宽、可靠性以及需要传输的数据量。</p><p>滑动窗口只有在队列前部的被确认之后，才会往后移动，保证数据包被接收方确认并接收。 其次是传输效率，假如没有窗口，服务端是杂乱无章地进行发包，</p><p>因为 TCP 的队首效应，如果有前面的包没有发送成功，就会不停的重试，反而造成更差的传输效率</p><h2 id="什么叫滑动窗口-receiver-window" tabindex="-1">什么叫滑动窗口 Receiver Window <a class="header-anchor" href="#什么叫滑动窗口-receiver-window" aria-label="Permalink to &quot;什么叫滑动窗口 Receiver Window&quot;">​</a></h2><ul><li>主要是控制流量的，根据频率不停调整，需要控制流量的方式</li><li>客户端服务器分别有自己缓存区，通过网络状况，调整发送数据大小</li></ul><h2 id="对头阻塞" tabindex="-1">对头阻塞 <a class="header-anchor" href="#对头阻塞" aria-label="Permalink to &quot;对头阻塞&quot;">​</a></h2><p>后面先到的，需要等待前面的完成，在进行窗口滑动</p><h2 id="超时重传-rto" tabindex="-1">超时重传 RTO <a class="header-anchor" href="#超时重传-rto" aria-label="Permalink to &quot;超时重传 RTO&quot;">​</a></h2><p>前面包丢了，再次重新传递</p><h2 id="探测" tabindex="-1">探测 <a class="header-anchor" href="#探测" aria-label="Permalink to &quot;探测&quot;">​</a></h2><p>当接收方的缓存满了，发送方每隔一端事件发一个探测包，来询问能否调整窗口，若上层协议主动消耗接收方数据，接收方也会主动通知客户端</p><h2 id="流量控制" tabindex="-1">流量控制 <a class="header-anchor" href="#流量控制" aria-label="Permalink to &quot;流量控制&quot;">​</a></h2><p>控制发送方的频率</p><h2 id="粘包" tabindex="-1">粘包 <a class="header-anchor" href="#粘包" aria-label="Permalink to &quot;粘包&quot;">​</a></h2><p>多个小包粘在一起</p><p>Nagle 任意时刻内， 只能有一个未被确认的小段 cork 小包合并成一个， 一起发送</p><h2 id="拥塞窗口-cwnd-congestion-window" tabindex="-1">拥塞窗口 cwnd (Congestion Window) <a class="header-anchor" href="#拥塞窗口-cwnd-congestion-window" aria-label="Permalink to &quot;拥塞窗口 cwnd (Congestion Window)&quot;">​</a></h2><p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。 于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。</p><ul><li>TCP 维护一个拥塞窗口 cwnd 变量，在传输过程中拥塞将此值增大，如果出现拥塞(超时重传 RTO)就将窗口值减少</li><li>cwnd &lt; ssthresh(慢启动门限（slow start threshold）) 慢开始算法 指数 2 4</li><li>cwnd &gt; ssthresh 拥塞避免算法 线性 16</li></ul><h2 id="快重传" tabindex="-1">快重传 <a class="header-anchor" href="#快重传" aria-label="Permalink to &quot;快重传&quot;">​</a></h2><p>发送过程中出现丢包情况，此时不要立即会退到慢开始阶段，而是对未收到的报文重复确认，如果确认次数到达 3 次，则立即进行重传 快恢复算法，减少超时重传机制的出现，降低重置 cwnd 的频率</p>',25),n=[i];function l(h,d,c,s,p,_){return t(),e("div",null,n)}const b=a(r,[["render",l]]);export{P as __pageData,b as default};
