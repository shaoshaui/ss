import{_ as a,a as t,o as l,aR as e}from"./chunks/framework.Dl98zJwX.js";const _=JSON.parse('{"title":"http 和 https 的区别","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/http/6.http 和 https 的区别.md","filePath":"前端/面试题/http/6.http 和 https 的区别.md","lastUpdated":1720604888000}'),h={name:"前端/面试题/http/6.http 和 https 的区别.md"},i=e('<h1 id="http-和-https-的区别" tabindex="-1">http 和 https 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;http 和 https 的区别&quot;">​</a></h1><p>http 基于 TCP 协议 传输控制协议 https 基于 TLS 协议，传输层安全协议</p><p>http 有一些缺点 端口号：80 https 443 窃听：明文传输 加密啊 篡改：代理商中间人劫持修改 摘要 认证：客户端服务器伪装，海量攻击请求 CA</p><h2 id="加密介绍" tabindex="-1">加密介绍 <a class="header-anchor" href="#加密介绍" aria-label="Permalink to &quot;加密介绍&quot;">​</a></h2><p>https 加密使用的加密套件 主要有：对称加密、非对称加密、椭圆 ECC、rsa hash 加密</p><h3 id="对称加密" tabindex="-1">对称加密： <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密：&quot;">​</a></h3><ul><li>用于数据传输阶段</li><li>服务器、客户端端共享一个密钥，密钥劫持，故怎样加密密钥</li></ul><h3 id="非对称加密" tabindex="-1">非对称加密： <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密：&quot;">​</a></h3><ul><li>服务器将自己信息 hash 和公钥，用自己私钥生成一个签名，给 CA 结构，CA 机构用自己私钥给它发一个签名</li><li>私钥加密公钥解，公钥加密，私钥验证，性能问题，效率不高，数据越大解密越复杂</li></ul><h2 id="数据上有安全性考虑吗-比如存储-比如说加密-秘钥生成-保存-加密解密-对-md5-使用吗-理解-md5-吗-唯一不可逆-断点上传-密码的保存-md5-加密-hash-一下" tabindex="-1">数据上有安全性考虑吗，比如存储，比如说加密，秘钥生成，保存，加密解密，对 md5 使用吗，理解 md5 吗，唯一不可逆，断点上传，密码的保存，md5，加密，hash 一下 <a class="header-anchor" href="#数据上有安全性考虑吗-比如存储-比如说加密-秘钥生成-保存-加密解密-对-md5-使用吗-理解-md5-吗-唯一不可逆-断点上传-密码的保存-md5-加密-hash-一下" aria-label="Permalink to &quot;数据上有安全性考虑吗，比如存储，比如说加密，秘钥生成，保存，加密解密，对 md5 使用吗，理解 md5 吗，唯一不可逆，断点上传，密码的保存，md5，加密，hash 一下&quot;">​</a></h2><p>密码: rsa 双层 md5</p><p><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/43789231</a></p><h2 id="对称加密问题-为什么要用对称加密-非对称加密" tabindex="-1">对称加密问题(为什么要用对称加密+非对称加密) <a class="header-anchor" href="#对称加密问题-为什么要用对称加密-非对称加密" aria-label="Permalink to &quot;对称加密问题(为什么要用对称加密+非对称加密)&quot;">​</a></h2><p>因为一个相同钥匙，在网络上传输，实际上等于明文，中间人可以获取到密钥进行传输</p><h2 id="非对称加密-为什么不能只用非对称加密" tabindex="-1">非对称加密(为什么不能只用非对称加密) <a class="header-anchor" href="#非对称加密-为什么不能只用非对称加密" aria-label="Permalink to &quot;非对称加密(为什么不能只用非对称加密)&quot;">​</a></h2><ul><li>客户端发送给服务器：客户端用(服务器的公钥)加密，服务器用自己私钥解开</li><li>服务器发送给客户端：服务器用(客户端的公钥)加密，客户端用自己私钥解开 带来重要问题：耗时间，</li></ul><h2 id="混合加密-非对称加密-对称加密-为什么需要数字证书" tabindex="-1">混合加密（非对称加密+对称加密）(为什么需要数字证书) <a class="header-anchor" href="#混合加密-非对称加密-对称加密-为什么需要数字证书" aria-label="Permalink to &quot;混合加密（非对称加密+对称加密）(为什么需要数字证书)&quot;">​</a></h2><ul><li>非对称：客户端发送给服务器：客户端用(服务器的公钥)加密自己的密钥，服务器用自己私钥解开的到密钥</li><li>对称加密：用密钥进行加密传输</li></ul><p>带来的问题：有可能出现狸猫换太子，根本原因是浏览器<strong>无法确认收到的公钥是不是网站自己</strong>的</p><ul><li>中间人劫持到公钥 A，保存下来，把数据包中的公钥 A 替换成自己伪造的公钥 B（它当然也拥有公钥 B 对应的私钥 B’）</li><li>中间人劫持后用私钥 B’解密得到密钥 X，再用公钥 A 加密后传给服务器。</li><li>服务器拿到后用私钥 A’ 解密得到密钥 X</li></ul><h2 id="ca-认证" tabindex="-1">CA 认证 <a class="header-anchor" href="#ca-认证" aria-label="Permalink to &quot;CA 认证&quot;">​</a></h2><ul><li>服务器：服务器将自己公钥传递给 CA 认证</li><li>CA 机构：CA 有自己的公钥和私钥，它把内容进行一个签名；签名把证书做个 hash 摘要，将摘要好的内容用私钥加密</li><li>客户端操作系统存储权威机构的根证书，可以进行验签，用内置的 CA 公钥进行解密，得到摘要。</li><li>将传递明文的摘要 和解密出来的进行匹配，如果一致就是合法的</li></ul><h2 id="https-加密过程" tabindex="-1">https 加密过程 <a class="header-anchor" href="#https-加密过程" aria-label="Permalink to &quot;https 加密过程&quot;">​</a></h2><ol><li><p>客户端发送一个 Clinet Hello 和随机数 Client Random, 以及自己支持的加密套件(密钥交换算法+签名算法+对称加密算法+摘要算法)</p></li><li><p>服务器发送一个 Server Hello 和随机数 Server Random, 选中一个客户端提供的加密套件</p></li><li><p>服务器发送自己 CA 机构颁发的证书，客户端获取到证书，验证签名，取出 服务器公钥</p></li><li><p>服务器发送一个 DH 参数签名后发送给客户端，客户端拿到服务器 DH，进行验签，证明参数是服务器给的</p></li><li><p>服务器发送 Server Hello Done</p></li><li><p>客户端发送一个 DH 随机参数，发送给服务器</p></li></ol><p>服务端有：随机数 C + 随机数 S + ServerParams DH + ClientParams DH =》 会话密钥 客户端有：随机数 C + 随机数 S + ServerParams DH + ClientParams DH =》 会话密钥</p><ol start="7"><li>客户端将换预主密钥发送给服务器</li><li>通过这个相同的密钥(对称加密)</li></ol><h2 id="随机数-防止重放攻击" tabindex="-1">随机数，防止重放攻击 <a class="header-anchor" href="#随机数-防止重放攻击" aria-label="Permalink to &quot;随机数，防止重放攻击&quot;">​</a></h2>',27),r=[i];function o(s,p,n,d,c,u){return l(),t("div",null,r)}const b=a(h,[["render",o]]);export{_ as __pageData,b as default};
