import{_ as l,a as r,o as a,b as e,d as t}from"./chunks/framework.Dl98zJwX.js";const v=JSON.parse('{"title":"compiler diff 原理","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/vue/10.compiler diff 原理.md","filePath":"前端/面试题/vue/10.compiler diff 原理.md","lastUpdated":1720603948000}'),i={name:"前端/面试题/vue/10.compiler diff 原理.md"},o=e("h1",{id:"compiler-diff-原理",tabindex:"-1"},[t("compiler diff 原理 "),e("a",{class:"header-anchor",href:"#compiler-diff-原理","aria-label":'Permalink to "compiler diff 原理"'},"​")],-1),d=e("ul",null,[e("li",null,[t("模版编译 优先级 render > template > el "),e("ul",null,[e("li",null,"template 生成 ast 树【用对象描述 JS 语法】，在生成 render 函数，然后挂载元素。"),e("li",null,"_render 调用 render 函数，拿到虚拟 DOM，_update 生成真实 DOM")])])],-1),n=e("p",null,"首先将我们的模版 template 转化成对象，在转化成可执行的 h crateElement 函数， 调用 render 方法将结点转化成 ast 虚拟 DOM 树， 在更新树的时候，进行 Diff 算法，对新旧值进行比对。",-1),s=e("p",null,"Diff 算法是一种 新旧结点更新的优化，利用了双指针。 先头和头、尾和尾、在老尾对应新头、老头对应新闻尾、存在的移动，不存在的新增，是的操作 dom 更新渲染变小。它的时间复杂度是 O(n)，两颗树的完全比对 时间复杂度是 O(n3)，vue 进行了优化，因为很少跨层级的操作移动 DOM, 所以只会比同一层级的 Vritual DOM。",-1),c=[o,d,n,s];function f(_,p,m,u,h,D){return a(),r("div",null,c)}const x=l(i,[["render",f]]);export{v as __pageData,x as default};
