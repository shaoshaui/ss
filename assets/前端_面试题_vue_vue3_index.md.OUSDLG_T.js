import{_ as e,a,o as t,aR as l}from"./chunks/framework.Dl98zJwX.js";const v=JSON.parse('{"title":"编译器 DLS","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/vue/vue3/index.md","filePath":"前端/面试题/vue/vue3/index.md","lastUpdated":1721112922000}'),r={name:"前端/面试题/vue/vue3/index.md"},i=l('<h1 id="编译器-dls" tabindex="-1">编译器 DLS <a class="header-anchor" href="#编译器-dls" aria-label="Permalink to &quot;编译器 DLS&quot;">​</a></h1><p>Vue 中的编译器是一个 特定领域 下的编译器, 领域专用语言</p><h1 id="vue3-编译主要流程" tabindex="-1">vue3 编译主要流程 <a class="header-anchor" href="#vue3-编译主要流程" aria-label="Permalink to &quot;vue3 编译主要流程&quot;">​</a></h1><p>通过 parse 方法进行解析，得到 AST (是一个用来描述模板的 JS 对象) 通过 transform 方法对 AST 进行转化，得到 JavaScript AST 通过 generate 方法根据 AST 生成 render 函数</p><p>Vue 中的编译器，本质上是把 template 模板转化为 render 函数，交给 runtime 运行的一段代码。</p><h1 id="vue3-编译做了哪些优化" tabindex="-1">vue3 编译做了哪些优化 <a class="header-anchor" href="#vue3-编译做了哪些优化" aria-label="Permalink to &quot;vue3 编译做了哪些优化&quot;">​</a></h1><blockquote><p>template -&gt; h -&gt; path move -&gt; render(h)</p></blockquote><ul><li>编译优化 (将模版编译 template 成渲染函数 h 的过程，尽可能区分静态和动态内容) <ul><li>静态提升，优化的是 template - h 静态内容直接引用，无需在重新编译，</li><li>标记动态结点: flagPath = 1，确认哪些可能会发生变化，参与 diff 比对</li><li>block tree 不再要求一个根结点，减少了 dom 层级的嵌套， v-if v-for v-else</li><li>预字符串模版，达到一定量的字符串，直接字符串本身，innerHtml 更新到页面上，减少生成静态的代码体积,</li><li>函数缓存，函数不会重新声明</li></ul></li></ul><p>vue3.0 做了哪些优化，从 响应式、编译器、运行时三个角度阐述</p>',9),o=[i];function n(d,u,s,p,c,h){return t(),a("div",null,o)}const m=e(r,[["render",n]]);export{v as __pageData,m as default};
