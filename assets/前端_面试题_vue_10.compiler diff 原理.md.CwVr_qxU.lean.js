import{_ as t,a,b as e,d as r,o as i}from"./chunks/framework.CqV2UAXh.js";const u=JSON.parse('{"title":"compiler diff 原理","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/vue/10.compiler diff 原理.md","filePath":"前端/面试题/vue/10.compiler diff 原理.md","lastUpdated":1727172427000}'),d={name:"前端/面试题/vue/10.compiler diff 原理.md"};function n(f,l,o,p,c,m){return i(),a("div",null,l[0]||(l[0]=[e("h1",{id:"compiler-diff-原理",tabindex:"-1"},[r("compiler diff 原理 "),e("a",{class:"header-anchor",href:"#compiler-diff-原理","aria-label":'Permalink to "compiler diff 原理"'},"​")],-1),e("ul",null,[e("li",null,[r("模版编译 优先级 render > template > el "),e("ul",null,[e("li",null,"template 生成 ast 树【用对象描述 JS 语法】，在生成 render 函数，然后挂载元素。"),e("li",null,"_render 调用 render 函数，拿到虚拟 DOM，_update 生成真实 DOM")])])],-1),e("p",null,"首先将我们的模版 template 转化成对象，在转化成可执行的 h crateElement 函数， 调用 render 方法将结点转化成 ast 虚拟 DOM 树， 在更新树的时候，进行 Diff 算法，对新旧值进行比对。",-1),e("p",null,"Diff 算法是一种 新旧结点更新的优化，利用了双指针。 先头和头、尾和尾、在老尾对应新头、老头对应新闻尾、存在的移动，不存在的新增，是的操作 dom 更新渲染变小。它的时间复杂度是 O(n)，两颗树的完全比对 时间复杂度是 O(n3)，vue 进行了优化，因为很少跨层级的操作移动 DOM, 所以只会比同一层级的 Vritual DOM。",-1)]))}const _=t(d,[["render",n]]);export{u as __pageData,_ as default};
