import{_ as l,a as i,o as a,aR as e}from"./chunks/framework.Dl98zJwX.js";const b=JSON.parse('{"title":"字符串","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/算法/总结.md","filePath":"前端/面试题/算法/总结.md","lastUpdated":1720611052000}'),t={name:"前端/面试题/算法/总结.md"},r=e('<h1 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h1><ul><li>字典序</li><li>字符串包含: avcd vc</li><li>无重复字符的最长子串: abcabc =&gt; abc</li><li>包含最短字符串: abcd, ca =&gt; abc</li><li>获取字符串没有重复的字符和长度: abcdabcd =&gt; abcd</li><li>最小覆盖子串</li></ul><h1 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h1><ul><li>之和 <ul><li>两数之和 [O(n)、O(n^2)]</li><li>有序两数之和 [头尾指针比对移动指针]</li><li>n 项和等于 sum</li></ul></li><li>重复 <ul><li>删除数组重复项[O(n)]</li><li>删除有序数组重复项 [快慢指针]</li><li>存在重复元素 [排序后快慢指针]</li></ul></li><li>环 <ul><li>回文 [头尾指针比对，不相等结束]</li><li>反转字符串 [头尾指针]</li><li>对称数</li><li>数组回环：3 =&gt; 5，4，3，1，2</li></ul></li><li>有序数组平方 [map.sort] [头尾指针排序]</li><li>洗牌</li><li>移动 0</li><li>数组最大连续和最大的字串</li><li>n * n 矩阵</li><li>寻找两个正序数组的中位数</li><li>跳跃游戏</li><li>接雨水</li></ul><h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><ul><li>遍历(广度层遍历)</li><li>深度\\轮廓\\行最大值</li><li>反转</li><li>树 -&gt; 数组、数组 -&gt; 树</li><li>二叉搜索树 <ul><li>验证[中序]、恢复[数组、排序]、有序数组转化二叉搜索树[找数组中间为根]、有序链表、搜索第 k 个小元素[中序遍历第 k]、搜索、插入</li></ul></li><li>对称二叉树[左右对比]、合并二叉树[左右相加]、平衡二叉树、</li><li>完全二叉树节点个数[左右+1]</li><li>数组转化为二叉树 [2*index+1]</li><li>二叉树的所有路径 &amp; 之和</li><li>二叉树的最近公共祖先</li></ul><h1 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h1><ul><li>反向输出</li><li>后序遍历</li><li>反转</li><li>有环、</li><li>删除、删除倒数、倒数第 K</li><li>翻转 n-m</li><li>回文：[快慢找中，反转比对]</li><li>有序合并：合并：k 个升序列表</li><li>相交链表</li><li>排序链表</li></ul><h1 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h1><ul><li>两个有序合并一个有序</li><li>冒泡、选择、插入、快速</li><li>最大 k 值的方法，用堆实现的，以及算法度</li></ul><h1 id="二分" tabindex="-1">二分 <a class="header-anchor" href="#二分" aria-label="Permalink to &quot;二分&quot;">​</a></h1><ul><li>二分查找、二叉搜索树插入位置</li><li>快排</li><li>判断子序列</li></ul><h1 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h1><ul><li>最长递增子序列</li><li>零钱兑换 找零钱，最少的硬币</li><li>最长公共子序列</li><li>最长回文子序列</li><li>最大子序和</li><li>买卖股票的最佳时机</li><li>背包</li></ul><h1 id="回溯" tabindex="-1">回溯 <a class="header-anchor" href="#回溯" aria-label="Permalink to &quot;回溯&quot;">​</a></h1><ul><li><p>N 皇后</p></li><li><p>全排列</p></li><li><p>括号生成</p></li><li><p>复原 IP 地址</p></li><li><p>子集</p></li><li><p>贪心：分发饼干、拆红包(100 拆 12 份)</p></li><li><p>斐波那契数</p></li><li><p>[1,2,3,4,5,6,7,8,9,10] 是一个列表，将他们首尾相接，求出 x 到 y 的最短距离，x、y 在列表中</p></li><li><p>文件上传，n 多文件上传，控制在 100m 内，实现文件数量最大，可以参考算法兑换零钱</p></li><li><p>求一个数值的平方根，如 6.6</p></li><li><p>数字转中文（滴滴，小红书）</p></li><li><p>查找某个 value 路径上的 key - 回溯</p></li><li><p>实现一个模版字符串</p></li><li><p>有效的括号</p></li><li><p>简化路径</p></li><li><p>下一个更大元素</p></li><li><p>最小栈</p></li><li><p><a href="https://codetop.cc/#/home" target="_blank" rel="noreferrer">https://codetop.cc/#/home</a></p></li><li><p><a href="https://juejin.cn/post/6947842412102287373#heading-42" target="_blank" rel="noreferrer">https://juejin.cn/post/6947842412102287373#heading-42</a></p></li><li><p>100 <a href="https://leetcode-cn.com/problem-list/2cktkvj/" target="_blank" rel="noreferrer">https://leetcode-cn.com/problem-list/2cktkvj/</a></p></li></ul>',16),o=[r];function p(n,c,h,d,s,u){return a(),i("div",null,o)}const m=l(t,[["render",p]]);export{b as __pageData,m as default};
