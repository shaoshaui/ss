import{_ as l,a as e,o as i,aR as a}from"./chunks/framework.Dl98zJwX.js";const s=JSON.parse('{"title":"HTTP 协议类","description":"","frontmatter":{},"headers":[],"relativePath":"前端/面试题/http/HTTP.md","filePath":"前端/面试题/http/HTTP.md","lastUpdated":1721110570000}'),t={name:"前端/面试题/http/HTTP.md"},o=a('<h1 id="http-协议类" tabindex="-1">HTTP 协议类 <a class="header-anchor" href="#http-协议类" aria-label="Permalink to &quot;HTTP 协议类&quot;">​</a></h1><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ul><li>HTTP 协议主要特点</li><li>报文组成</li><li>方法</li><li>POST GET 区别</li><li>状态码</li><li>持久链接</li><li>管线化</li></ul><h3 id="http-协议主要特点" tabindex="-1">HTTP 协议主要特点 <a class="header-anchor" href="#http-协议主要特点" aria-label="Permalink to &quot;HTTP 协议主要特点&quot;">​</a></h3><blockquote><p>简单快速 灵活 <code>无连接 无状态</code></p></blockquote><p>简单快速：uri 固定统一资源符 灵活：头数据类型，通过 http 协议完成不同类型传输 无链接：链接一次断掉 无状态：客户服务端是两种身份,无法区分上下次链接身份</p><h3 id="报文组成" tabindex="-1">报文组成 <a class="header-anchor" href="#报文组成" aria-label="Permalink to &quot;报文组成&quot;">​</a></h3><ul><li><p>请求报文</p><blockquote><p>请求行 请求头 空行 请求体 请求行：http 方法 页面地址 http 协议 以及 版本 实例：GET / HTTP/1.1 请求头：key value 类型告诉服务器要什么类型 实例：Host Cookie Accept Connection Cache-Control 空行：告诉服务端 请求头结束 请求体：数据部分</p></blockquote></li><li><p>响应报文 状态行 响应头 空行 响应体 响应行：HTTP/1.1 200 ok 响应头：Server Date Set-Cookie</p></li></ul><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><ul><li>GET 获取</li><li>POST 传输</li><li>PUT 更新</li><li>DELETE 删除</li><li>HEAD 获取报文首部</li></ul><h3 id="post-get-区别" tabindex="-1">POST GET 区别 <a class="header-anchor" href="#post-get-区别" aria-label="Permalink to &quot;POST GET 区别&quot;">​</a></h3><ul><li><code>GET在浏览器退回无害，POST会再次提交请求</code></li><li>GET 地址会收藏，POST 不可以</li><li><code>GET会被自动主动缓存，POST不可以，除非手动设置</code></li><li>GET 只能进行 url 编码，而 POST 支持多种编码方式</li><li><code>GET参数会被完整保留浏览器历史记录里面，而POST不会</code></li><li><code>GET在URL中传参长度有所限制，而POST没限制</code></li><li>对参数类型，GET 支持 ASCII,而 POST 没有</li><li>GET 比 POST 更不安全，因为参数暴露在 URL 中，不能传递敏感信息</li><li><code>GET参数放在URL中，POST放到请求体 Request Body</code></li></ul><h3 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h3><ul><li><p>1XX 指示信息，请求已接收，继续处理</p></li><li><p>2XX 成功 206 Partial Content 客服端发送一带 Range 头的 get 请求，服务器继续完成它，音频地址</p></li><li><p>3XX 重定向 要完成请求必须进行更进一步操作 301 永久重定向；Moved 所有页面已经转移到新的 URL 302 临时重定向；请求页面已经临时转移到新的 URL 304 缓存；Not Modified 客户端有缓冲的文档，并发出一个条件性请求，服务器告诉客户端，原来缓冲的文档的还能用</p></li><li><p>4XX 客户端错误 请求语法错误或者请求无法实现 400 客户端语法错误 401 未授权 403 请求被禁用，资源被禁止，只能通过服务器访问</p></li><li><p>5XX 服务器端错误 服务器未能合法请求<br> 503 服务器临时过载或当机，一段时间会恢复</p></li></ul><h3 id="持久链接" tabindex="-1">持久链接 <a class="header-anchor" href="#持久链接" aria-label="Permalink to &quot;持久链接&quot;">​</a></h3><ul><li>HTTP 采用的是”请求-应答“模式，当使用普通模式，既非 Keep-Alive 模式时，每个请求/应答服务器客户端都需要新建一个链接，完成之后立即断开</li><li>当使用 Keep-Alive 模式（持久连接，连接重用）Keep-Alive 的功能是客户端服务器连接持久有效（HTTP1.1 版本支持）</li><li>长链接，复用了 TCP</li></ul><h3 id="管线化" tabindex="-1">管线化 <a class="header-anchor" href="#管线化" aria-label="Permalink to &quot;管线化&quot;">​</a></h3><p>-<code>持久连接</code>情况下，某个连接上的消息传递类似 请求 1-&gt;响应 1-&gt;请求 2-&gt;响应 2-&gt;请求 3-&gt;响应 3</p><ul><li><p>某个连接的消息变成了类似 请求 1-&gt;请求 2-&gt;请求 3-&gt;响应 1-&gt;响应 2-&gt;响应 3</p></li><li><p>管线化机制通过<code>持久连接</code>完成,仅 HTTP1.1 版本支持</p></li><li><p><code>只有GET HEAD可以进行管线化，POST有限制</code></p></li><li><p><code>初次建立连接时不应启动管线化，因为对方HTTP版本不支持</code></p></li><li><p>管线化不会影响响应到来的顺序</p></li><li><p>HTTP1.1 要求服务器支持管线化，但并不要求对响应进行管线化处理，还是要求对管线化请求不失败即可</p></li><li><p>开启管线化，可能并不会带来大幅性能提升，而且很多服务器和代理对管线化支持不太好，因此 Chrome Firefox 默认并未开启管线化支持</p></li><li><p>每个域名分配 6 个 tcp 通道，域名也不易过多，过多 DNS</p></li></ul><h3 id="技巧-了解管线化的原理并且会用-我这块没有了解的那么细-因为这块在业务中已经够用了-有什么好的资料推荐么" tabindex="-1">技巧：了解管线化的原理并且会用，我这块没有了解的那么细，因为这块在业务中已经够用了，有什么好的资料推荐么 <a class="header-anchor" href="#技巧-了解管线化的原理并且会用-我这块没有了解的那么细-因为这块在业务中已经够用了-有什么好的资料推荐么" aria-label="Permalink to &quot;技巧：了解管线化的原理并且会用，我这块没有了解的那么细，因为这块在业务中已经够用了，有什么好的资料推荐么&quot;">​</a></h3>',20),r=[o];function T(d,h,c,p,n,P){return i(),e("div",null,r)}const _=l(t,[["render",T]]);export{s as __pageData,_ as default};
